#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include "CImg.h"
#define PI 3.14159265
#define rad PI/180
#define g	9.8		//gravity
#define time_step  0.01
#define length 1	//unit: m
#define length_2  1	//unit: m
#define m1  1   // unit: Kg
#define m2  1  // unit: Kg
//#define damping_accelerate 0.8 //unit Kg
using namespace cimg_library;

int main()
{
	int size_x = 640;
	int size_y = 500;
	int size_z = 1;
	int numberOfColorChannels = 3; // R G B
	unsigned char initialValue = 0;
	//-------define the image and window-------------------------//
	CImg<unsigned char> blank(size_x, size_y, size_z, numberOfColorChannels, initialValue), paper;
	CImgDisplay disp(blank, "Pendulum");


	//----------------Variable define-----------------------------//
	const unsigned char color_circle[] = { 250, 100, 0 }, white[] = { 255,255,255 }, color_car[] = { 255, 255, 0 };
	float x = disp.width() / 2, y = 0 ,x2=0,y2=0;
	float angle_degree_1 = 0, shift_angle_1=0, angle_speed_1 = 0, angular_accelerate_1=0;
	float angle_degree_2 = 0, shift_angle_2=0, angle_speed_2 = 0, angular_accelerate_2=0;
	float angle_1 = angle_degree_1 * rad;
	float angle_2 = angle_degree_2 * rad;
	float Force_A = 0 , A = 0, Sv = 0, Sx = (disp.width() / 2), Sy = (disp.height() / 2);
	float k = 0,a=0,b=0;
	//---------------Moving force calculation------------------------------//
	while (!disp.is_closed() && !disp.is_keyQ() && !disp.is_keyESC())
	{

		//----------Damping parameter contorl--------------------//
		if (disp.is_keyARROWUP())
			k += 0.02;
		if (disp.is_keyARROWDOWN())
			if (k > 0)
				k -= 0.02;
			else
				k = 0;


		/*--------Original Friction calculation-------------------//
		if (disp.is_keyARROWLEFT())
			A -= 300;
		if (disp.is_keyARROWRIGHT())
			A += 300;

		Sv += A * time_step;
		Sx += Sv * time_step;
		A = A * 0.003;
		*/

		if (disp.is_keyARROWLEFT())
			Force_A = -3;
		else if (disp.is_keyARROWRIGHT())
			Force_A = 3;
		else
			Force_A = 0;
		Sv += Force_A * 150 * time_step;     // 100 is for amplifer the value for the item moving evidently
		Sx += Sv * time_step;
		//-----------------Friction calculation--------------------//
		if (Sv > 0.3)
			Sv -= 0.3;
		else if (Sv < -0.3)
			Sv += 0.3;
		else
			Sv = 0;

		A = Sv/(1.5*50);  // the power for moving the pedulum
		
		
		
	//----------------- acceleration calculation--------------------------//
		

		/*----------acceleration calculation without damping----------------------------------//
		angular_accelerate_2 = (A)* cos(angle_2 / length_2) + ((2 * sin(angle_1 - angle_2)*(angle_speed_1*angle_speed_1*length*(m1 + m2) + g * (m1 + m2)*cos(angle_1) + angle_speed_2 * angle_speed_2*length_2*m2*cos(angle_1 - angle_2))) / (length_2*(2 * m1 + m2 - m2 * cos(2 * angle_1 - 2 * angle_2))));

		angular_accelerate_1 = (A) * cos(angle_1/ length)+((((-g)*(2 * m1 + m2)*sin(angle_1)) - (m2*g*sin(angle_1 - 2 * angle_2)) - (2 * sin(angle_1 - angle_2)*m2*(angle_speed_2*angle_speed_2*length_2 + angle_speed_1 * angle_speed_1*length*cos(angle_1 - angle_2))))/(length*(2*m1+m2-m2*cos(2*angle_1-2*angle_2))));
		*/		
		a = k * angle_speed_1;
		b = k * angle_speed_2;
		angular_accelerate_2 = (A)* cos(angle_2 / length_2) +(((m2*length_2*angle_speed_2*angle_speed_2*sin(2*(angle_1-angle_2)))+ (2*(m1+m2)*length*angle_speed_1*angle_speed_1*sin(angle_1-angle_2))+(2*g*(m1+m2)*cos(angle_1)*sin(angle_1-angle_2))+(2*a*cos(angle_1-angle_2)-((2*(m1+m2)*b)/m2)))/ (2 * length_2*(m1 + m2 * sin(angle_1 - angle_2)*sin(angle_1 - angle_2))));

		angular_accelerate_1 = (A)* cos(angle_1 / length) + (((m2*length*angle_speed_1*angle_speed_1*sin(2 * (angle_1 - angle_2))) + (2*m2*length_2*angle_speed_2*angle_speed_2*sin(angle_1-angle_2))+(2*g*m2*cos(angle_2)*sin(angle_1-angle_2))+(2*g*m1*sin(angle_1))+(2*a-2*b*cos(angle_1-angle_2)))/(-2*length*(m1+m2*sin(angle_1-angle_2)*sin(angle_1 - angle_2))));


		angle_speed_1 += angular_accelerate_1*time_step;
		angle_1 += angle_speed_1 * time_step;
		angle_speed_2 += angular_accelerate_2 * time_step;
		angle_2 += angle_speed_2 * time_step;

		while (angle_1 > PI)
			angle_1 -= (2 * PI);
		while (angle_1 <= -PI)
			angle_1 += (2 * PI);

		while (angle_2 > PI)
			angle_2 -= (2 * PI);
		while (angle_2 <= -PI)
			angle_2 += (2 * PI);
		
		//--------------------------Graphing-------------------------------//
		y = Sy + 100 * length * cos(angle_1);
		x = Sx - 100 * length * sin(angle_1);
		y2 = y + 100 * length_2 * cos(angle_2);
		x2 = x - 100 * length_2 * sin(angle_2);

		//----------------------------------------------------------------//

		paper = blank;
		paper.draw_rectangle(Sx -10, Sy -10, Sx +10, Sy +10, color_car);
		paper.draw_line(Sx,Sy, x, y, white);
		paper.draw_ellipse(x, y, 10, 10, 0, color_circle);
		paper.draw_line(x, y, x2, y2, white);
		paper.draw_ellipse(x2, y2, 10, 10, 0, color_circle);
		paper.draw_text(0, 0, " Damping constant: %f\n item speed: %f \n angular_accelerate_1: %f \n angular_accelerate_2: %f \n Length_1: %d \n Length_2: %d \n M1: %d \n M2: %d\n", white, 0, 0.7f, 16,k, Sv, angular_accelerate_1, angular_accelerate_2,length, length_2,m1,m2);
		//-------------------------FPS------------------------------------//
		disp.display(paper).wait(5);


		//-------------------------Print Data------------------------------------//
		//printf("angle_1 %4f	angle_speed_1=  %4f	angular_accelerate_1= %4f\n", 180*(angle_1/PI), angle_speed_1, angular_accelerate_1);
		//printf("angle_2 %4f	angle_speed_2=  %4f	angular_accelerate_2= %4f\n", 180 * (angle_2 / PI), angle_speed_2, angular_accelerate_2);
		//-------------------------Changing Windows size------------------------------------//
		if (disp.is_resized())
		{
			blank.resize(disp.resize(disp.window_width() > 200 ? disp.window_width() : 200, disp.height(), false));
			Sx = (disp.width() / 2);
			Sy = (disp.height() / 2);
		}
	}

	return 0;
}